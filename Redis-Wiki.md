# Redis Wiki

## Redis 特性

* **特性一**，速度极快。官方给出的数据是 10 万次 ops 的读写，这主要归功于这些数据都存在于内存中。由于 Redis 是开源的，当你打开源代码，就会发现 Redis 都是用 C 语言写的，C 语言是最接近计算机语言的代码，而且只有区区 5 万行，保证了 Redis 的速度。同时一个 Redis 只是一个单线程，其真正的原因还是因为单线程在内存中是效率最高的。

* **特性二**，持久化。Redis 的持久化可以保证将内存中的数据每隔一段时间就保存于磁盘中，重启的时候会再次加载到内存。持久化方式是 RDB 和 AOF。

* **特性三**，支持多种数据结构。分别支持哈希、集合、BitMaps，还有位图（多用于活跃用户数等统计）、HyperLogLog（超小内存唯一值计数，由于只有 12K，是有一定误差范围的）、GEO（地理信息定位）。

* **特性四**，支持多种编程语言。支持Java、PHP、Python、Ruby、Lua、Nodejs。

* **特性五**，功能丰富。如发布订阅、Lua 脚本、事务、Pipeline（管道，即当指令到达一定数量后，客户端才会执行）。

* **特性六**，简单。不依赖外部库、单线程、只有 23000 行 Code。

* **特性七**，主从复制。主节点的数据做副本，这是做高可用的基石。

* **特性八**，高可用和分布式。Redis-Sentinel（v2.8）支持高可用，Redis-Cluster（v3.0）支持分布式。

## Redis应用场景

* **1.缓存系统**。这是 Redis 使用最多的场景。Redis 能够替代 Memcached，让你的缓存从只能存储数据变得能够更新数据，因此你不再需要每次都重新生成数据。毫无疑问，Redis 缓存使用的方式与 Memcache 相同。网络中总是能够看到这个技术更新换代，Redis 的原生命令，尽管简单却功能强大，把它们加以组合，能完成的功能是无法想象的。当然，你可以专门编写代码来完成所有这些操作，但 Redis 实现起来显然更为轻松。

* **2.计数器**。如转发数、评论数，有了原子递增（Atomic Increment），你可以放心的加上各种计数，用GETSET重置，或者是让它们过期。目前新浪是号称史上最大的 Redis 集群。比如，你想计算出最近用户在页面间停顿不超过 30 秒的页面浏览量，当计数达到比如 10 时，就可以显示提示。再比如，如果想知道什么时候封锁一个 IP 地址，INCRBY命令让这些变得很容易，通过原子递增保持计数；GETSET用来重置计数器；过期属性用来确认一个关键字什么时候应该删除。

* **3.消息队列系统**。虽然 Kafka 更强，但是简单的可以使用 Redis。运行稳定并且快速，支持模式匹配，能够实时订阅与取消频道。Redis 还有阻塞队列的命令，能够让一个程序在执行时被另一个程序添加到队列。你也可以做些更有趣的事情，比如一个旋转更新的 RSS Feed 队列。

* **4.排行榜及相关问题**。实际就是一种有序集合。对于 Redis 来说，如果你要在几百万个用户中找到排名，其他数据库查询是非常慢的，因为每过几分钟，就会有几百万个不同的数据产生变化，但是 Redis 却可以轻松解决。排行榜（Leader Board）按照得分进行排序。ZADD 命令可以直接实现这个功能，而 ZREVRANGE 命令可以用来按照得分获取前 100 名的用户，ZRANK 可以用来获取用户排名，非常直接而且操作容易。

* **5.社交网络**。Redis 可以非常好地与社交网络相结合，如新浪微博、Twiter等，比如QQ和用户交互的时候，用户和状态消息将会聚焦很多有用的信息，很多交互如实时聊天就是通过 Redis 来实现的。

* **6.按照用户投票和时间排序**。Reddit 的排行榜，得分会随着时间变化。LPUSH 和 LTRIM 命令结合运用，把文章添加到一个列表中。一项后台任务用来获取列表，并重新计算列表的排序，ZADD 命令用来按照新的顺序填充生成列表。列表可以实现非常快速的检索，即使是负载很重的站点。

* **7.过期项目处理**。通过 Unix 时间作为关键字，用来保持列表能够按时间排序。对 currenttime 和 timeto_live 进行检索，完成查找过期项目的艰巨任务。另一项后台任务使用 ZRANGE...WITHSCORES 进行查询，删除过期的条目。

* **8.实时系统**。使用位图来做布隆过滤器，例如实现垃圾邮件过滤系统的开发变的非常容易。
